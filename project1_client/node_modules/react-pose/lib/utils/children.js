"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var Children = React.Children, cloneElement = React.cloneElement;
var getKey = function (child) { return child.key; };
var animateChildrenList = function (incomingChildren, pose, initialPose) {
    var children = [];
    Children.forEach(incomingChildren, function (child) {
        return children.push(cloneElement(child, { pose: pose, initialPose: initialPose }));
    });
    return children;
};
var mergeChildren = function (_a) {
    var incomingChildren = _a.incomingChildren, displayedChildren = _a.displayedChildren, isLeaving = _a.isLeaving, removeFromTree = _a.removeFromTree, preEnterPose = _a.preEnterPose, enterPose = _a.enterPose, exitPose = _a.exitPose, flipMove = _a.flipMove;
    var children = [];
    var prevKeys = displayedChildren.map(getKey);
    var nextKeys = incomingChildren.map(getKey);
    var entering = new Set(nextKeys.filter(function (key) { return isLeaving.has(key) || prevKeys.indexOf(key) === -1; }));
    entering.forEach(function (key) { return isLeaving.delete(key); });
    var leaving = prevKeys.filter(function (key) {
        return !entering.has(key) && (isLeaving.has(key) || nextKeys.indexOf(key) === -1);
    });
    leaving.forEach(function (key) { return isLeaving.add(key); });
    var moving = new Set(prevKeys.filter(function (key, i) {
        var nextIndex = nextKeys.indexOf(key);
        return !entering.has(key) && nextIndex !== -1 && i !== nextIndex;
    }));
    incomingChildren.forEach(function (child) {
        var newChildProps = entering.has(child.key)
            ? { initialPose: preEnterPose, pose: enterPose }
            : moving.has(child.key) && flipMove
                ? { pose: [enterPose, 'flip'] }
                : { pose: enterPose };
        children.push(cloneElement(child, newChildProps));
    });
    leaving.forEach(function (key) {
        var child = displayedChildren.find(function (c) { return c.key === key; });
        var newChild = cloneElement(child, {
            pose: exitPose,
            onPoseComplete: removeFromTree(key),
            popFromFlow: flipMove
        });
        var insertionIndex = prevKeys.indexOf(key);
        if (insertionIndex) {
        }
        children.splice(insertionIndex, 0, newChild);
    });
    return children;
};
exports.handleIncomingChildren = function (props) {
    var displayedChildren = props.displayedChildren, incomingChildren = props.incomingChildren, animateOnMount = props.animateOnMount, preEnterPose = props.preEnterPose, enterPose = props.enterPose;
    if (!displayedChildren && animateOnMount) {
        return animateChildrenList(incomingChildren, enterPose, preEnterPose);
    }
    else if (displayedChildren) {
        return mergeChildren(props);
    }
    else {
        return animateChildrenList(incomingChildren, enterPose);
    }
};
exports.makeChildList = function (children) {
    var list = [];
    Children.forEach(children, function (child) { return child && list.push(child); });
    return list;
};
exports.removeFromChildren = function (children, key) {
    return children.filter(function (child) { return child.key !== key; });
};
//# sourceMappingURL=children.js.map