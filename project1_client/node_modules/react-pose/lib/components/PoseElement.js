"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_1 = require("react");
var popmotion_pose_1 = require("popmotion-pose");
exports.PoseParentContext = react_1.createContext({});
var calcPopFromFlowStyle = function (el) {
    var offsetTop = el.offsetTop, offsetLeft = el.offsetLeft, offsetWidth = el.offsetWidth, offsetHeight = el.offsetHeight;
    return {
        position: 'absolute',
        top: offsetTop,
        left: offsetLeft,
        width: offsetWidth,
        height: offsetHeight
    };
};
var hasPose = function (pose, key) {
    return Array.isArray(pose) ? pose.indexOf(key) !== -1 : pose === key;
};
var objectToMap = function (obj) {
    return Object.keys(obj).reduce(function (map, key) {
        map.set(key, obj[key]);
        return map;
    }, new Map());
};
var PoseElement = (function (_super) {
    __extends(PoseElement, _super);
    function PoseElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.children = new Set();
        _this.childrenHandlers = {
            registerChild: function (props) {
                _this.children.add(props);
                if (_this.poser)
                    _this.flushChildren();
            },
            onUnmount: function (child) { return _this.poser.removeChild(child); },
            getParentPoseProps: function () { return _this.props.poseProps; },
            getPoseFromParent: function () { return _this.props.pose; }
        };
        _this.setRef = function (ref) {
            var innerRef = _this.props.innerRef;
            if (innerRef)
                innerRef(ref);
            _this.ref = ref;
        };
        return _this;
    }
    PoseElement.prototype.getInitialPose = function () {
        var _a = this.props, getPoseFromParent = _a.getPoseFromParent, pose = _a.pose, initialPose = _a.initialPose;
        if (initialPose) {
            return initialPose;
        }
        else {
            var parentPose = getPoseFromParent && getPoseFromParent();
            var thisPose = Array.isArray(pose) ? pose : [pose];
            return Array.isArray(parentPose)
                ? parentPose.concat(thisPose) : [parentPose].concat(thisPose);
        }
    };
    PoseElement.prototype.getSetProps = function () {
        var _a = this.props, children = _a.children, elementType = _a.elementType, poseProps = _a.poseProps, onChange = _a.onChange, innerRef = _a.innerRef, pose = _a.pose, initialPose = _a.initialPose, onPoseComplete = _a.onPoseComplete, newTree = _a.newTree, getParentPoseProps = _a.getParentPoseProps, registerChild = _a.registerChild, onUnmount = _a.onUnmount, getPoseFromParent = _a.getPoseFromParent, popFromFlow = _a.popFromFlow, values = _a.values, parentValues = _a.parentValues, props = __rest(_a, ["children", "elementType", "poseProps", "onChange", "innerRef", "pose", "initialPose", "onPoseComplete", "newTree", "getParentPoseProps", "registerChild", "onUnmount", "getPoseFromParent", "popFromFlow", "values", "parentValues"]);
        if (popFromFlow && this.ref && this.ref instanceof HTMLElement) {
            if (!this.popStyle) {
                props.style = __assign({}, props.style, calcPopFromFlowStyle(this.ref));
                this.popStyle = props.style;
            }
            else {
                props.style = this.popStyle;
            }
        }
        else {
            this.popStyle = null;
        }
        return props;
    };
    PoseElement.prototype.componentDidMount = function () {
        var _this = this;
        if (!this.ref)
            return;
        var _a = this.props, poseProps = _a.poseProps, onChange = _a.onChange, registerChild = _a.registerChild, values = _a.values, parentValues = _a.parentValues;
        var props = __assign({}, poseProps, { initialPose: this.getInitialPose(), values: values, parentValues: parentValues ? objectToMap(parentValues) : parentValues, onChange: onChange });
        if (!registerChild) {
            this.initPoser(popmotion_pose_1.default(this.ref, props));
        }
        else {
            registerChild({
                element: this.ref,
                poserProps: props,
                onRegistered: function (poser) { return _this.initPoser(poser); }
            });
        }
    };
    PoseElement.prototype.UNSAFE_componentWillUpdate = function (_a) {
        var pose = _a.pose;
        if (hasPose(pose, 'flip'))
            this.poser.measure();
    };
    PoseElement.prototype.componentDidUpdate = function (prevProps) {
        var pose = this.props.pose;
        this.poser.setTransitionProps(this.getSetProps());
        if (pose !== prevProps.pose || pose === 'flip')
            this.setPose(pose);
    };
    PoseElement.prototype.componentWillUnmount = function () {
        if (!this.poser)
            return;
        var onUnmount = this.props.onUnmount;
        if (onUnmount)
            onUnmount(this.poser);
        this.poser.destroy();
    };
    PoseElement.prototype.initPoser = function (poser) {
        var _a = this.props, initialPose = _a.initialPose, pose = _a.pose;
        this.poser = poser;
        if (initialPose && pose)
            this.setPose(pose);
        this.poser.setTransitionProps(this.getSetProps());
        this.flushChildren();
    };
    PoseElement.prototype.setPose = function (pose) {
        var _this = this;
        var onPoseComplete = this.props.onPoseComplete;
        var poseList = Array.isArray(pose) ? pose : [pose];
        Promise.all(poseList.map(function (key) { return key && _this.poser.set(key); })).then(function () { return onPoseComplete && onPoseComplete(); });
    };
    PoseElement.prototype.flushChildren = function () {
        var _this = this;
        this.children.forEach(function (_a) {
            var element = _a.element, poserProps = _a.poserProps, onRegistered = _a.onRegistered;
            return onRegistered(_this.poser.addChild(element, poserProps));
        });
        this.children.clear();
    };
    PoseElement.prototype.render = function () {
        var _a = this.props, elementType = _a.elementType, children = _a.children;
        var props = this.getSetProps();
        return (React.createElement(exports.PoseParentContext.Provider, { value: this.childrenHandlers }, react_1.createElement(elementType, __assign({}, props, { ref: this.setRef }), children)));
    };
    return PoseElement;
}(React.PureComponent));
exports.PoseElement = PoseElement;
//# sourceMappingURL=PoseElement.js.map