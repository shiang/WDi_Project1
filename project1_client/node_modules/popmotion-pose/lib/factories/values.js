"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selectors_1 = require("../inc/selectors");
var style_value_types_1 = require("style-value-types");
var transformers_1 = require("popmotion/transformers");
var value_1 = require("popmotion/reactions/value");
var valueTypeTests = [style_value_types_1.number, style_value_types_1.degrees, style_value_types_1.percent, style_value_types_1.px];
var testValueType = function (v) { return function (type) { return type.test(v); }; };
var getInitialValue = function (poses, key, initialPose, styler) {
    var posesToSearch = Array.isArray(initialPose)
        ? initialPose
        : [initialPose];
    var pose = posesToSearch.find(function (name) { return poses[name] && poses[name][key] !== undefined; });
    return pose ? poses[pose][key] : styler.get(key);
};
var createValues = function (values, types, _a, pose) {
    var initialPose = _a.initialPose, poses = _a.poses, styler = _a.styler, userSetValues = _a.userSetValues;
    return function (key) {
        if (values.has(key))
            return;
        var thisValue;
        var type;
        if (userSetValues && userSetValues[key] !== undefined) {
            thisValue = userSetValues[key];
            type = valueTypeTests.find(testValueType(thisValue.get()));
        }
        else {
            var initialValue = getInitialValue(poses, key, initialPose, styler);
            type = valueTypeTests.find(testValueType(pose[key]));
            thisValue = value_1.default(type === style_value_types_1.number ? type.parse(initialValue) : initialValue);
        }
        values.set(key, thisValue);
        thisValue.subscribe(function (v) { return styler.set(key, v); });
        if (type && type !== style_value_types_1.number)
            types.set(key, type);
    };
};
var scrapeValuesFromPose = function (values, types, props) { return function (key) {
    var pose = props.poses[key];
    Object.keys(selectors_1.getPoseValues(pose)).forEach(createValues(values, types, props, pose));
}; };
var bindPassiveValues = function (values, _a) {
    var passive = _a.passive, parentValues = _a.parentValues, styler = _a.styler;
    return function (key) {
        var _a = passive[key], valueKey = _a[0], transform = _a[1], fromParent = _a[2];
        var valueToBind = fromParent && parentValues && parentValues.has(valueKey)
            ? parentValues.get(valueKey)
            : values.has(valueKey) ? values.get(valueKey) : false;
        if (!valueToBind)
            return;
        var newValue = value_1.default(valueToBind.get(), transformers_1.pipe(transform, function (v) { return styler.set(key, v); }));
        valueToBind.subscribe(newValue);
        values.set(key, newValue);
    };
};
var bindOnChange = function (values, onChange) { return function (key) {
    if (values.has(key))
        values.get(key).subscribe(onChange[key]);
}; };
var createValuesAndTypes = function (props) {
    var passive = props.passive, poses = props.poses, onChange = props.onChange;
    var values = new Map();
    var types = new Map();
    Object.keys(poses).forEach(scrapeValuesFromPose(values, types, props));
    if (passive)
        Object.keys(passive).forEach(bindPassiveValues(values, props));
    if (onChange)
        Object.keys(onChange).forEach(bindOnChange(values, onChange));
    return { values: values, types: types };
};
exports.default = createValuesAndTypes;
//# sourceMappingURL=values.js.map