"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chain_1 = require("popmotion/compositors/chain");
var delay_1 = require("popmotion/compositors/delay");
var flip_1 = require("../dom/flip");
var default_transitions_1 = require("../inc/default-transitions");
var selectors_1 = require("../inc/selectors");
var startChildAnimations = function (children, next, nextPose, props) {
    var animations = [];
    var delay = 0;
    var stagger = 0;
    var staggerDirection = 1;
    if (nextPose) {
        delay = nextPose.delayChildren || delay;
        stagger = nextPose.staggerChildren || stagger;
        staggerDirection = nextPose.staggerDirection || staggerDirection;
    }
    var maxStaggerDuration = (children.size - 1) * stagger;
    var generateStaggerDuration = staggerDirection === 1
        ? function (i) { return i * stagger; }
        : function (i) { return maxStaggerDuration - i * stagger; };
    Array.from(children).forEach(function (child, i) {
        animations.push(child.set(next, __assign({}, props, { delay: delay + generateStaggerDuration(i) })));
    });
    return animations;
};
var createPoseSetter = function (setterProps) { return function (next, props) {
    if (props === void 0) { props = {}; }
    var _a = props.delay, delay = _a === void 0 ? 0 : _a;
    var activeActions = setterProps.activeActions, activePoses = setterProps.activePoses, children = setterProps.children, poses = setterProps.poses, dimensions = setterProps.dimensions, values = setterProps.values, types = setterProps.types, dragProps = setterProps.dragProps, getTransitionProps = setterProps.getTransitionProps, flipEnabled = setterProps.flipEnabled;
    var animations = [];
    var dragBounds = dragProps.dragBounds;
    var nextPose = poses[next];
    if (nextPose) {
        if (flipEnabled && flip_1.isFlipPose(nextPose, next))
            nextPose = flip_1.flipPose(setterProps, nextPose);
        var getTransition_1 = nextPose.transition;
        var poserAnimations = Object.keys(selectors_1.getPoseValues(nextPose)).map(function (key) {
            return new Promise(function (complete) {
                var value = values.get(key);
                var type = types.get(key);
                var from = value.get();
                var unparsedTarget = nextPose[key];
                if (activeActions.has(key))
                    activeActions.get(key).stop();
                var transition = getTransition_1(__assign({ from: type ? type.parse(from) : from, velocity: value.getVelocity() || 0, to: type ? type.parse(unparsedTarget) : unparsedTarget, key: key, prevPoseKey: activePoses.get(key), dimensions: dimensions,
                    dragBounds: dragBounds,
                    type: type }, getTransitionProps(), props));
                if (transition === false)
                    transition = default_transitions_1.just(unparsedTarget);
                if (delay || nextPose.delay) {
                    transition = chain_1.default(delay_1.default(delay || nextPose.delay), transition);
                }
                if (type)
                    transition = transition.pipe(type.transform);
                var transitionApi = transition.start({
                    update: function (v) { return value.update(v); },
                    complete: complete
                });
                activeActions.set(key, transitionApi);
                activePoses.set(key, next);
            });
        });
        animations.push.apply(animations, poserAnimations);
    }
    if (children.size)
        animations.push.apply(animations, startChildAnimations(children, next, nextPose, props));
    return Promise.all(animations);
}; };
exports.default = createPoseSetter;
//# sourceMappingURL=pose-setter.js.map