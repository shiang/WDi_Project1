'use strict';

exports.__esModule = true;
exports.flipPose = exports.isFlipPose = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _value = require('popmotion/reactions/value');

var _value2 = _interopRequireDefault(_value);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var positionalProps = new Set(['width', 'height', 'top', 'left', 'bottom', 'right']);
var checkPositionalProp = function checkPositionalProp(key) {
  return positionalProps.has(key);
};
var hasPositionalProps = function hasPositionalProps(pose) {
  return Object.keys(pose).some(checkPositionalProp);
};
var isFlipPose = exports.isFlipPose = function isFlipPose(pose, key) {
  return hasPositionalProps(pose) || key === 'flip';
};

var setValue = function setValue(_ref, key, to) {
  var values = _ref.values,
      elementStyler = _ref.elementStyler;

  if (values.has(key)) {
    // Here, if we already have the value, we update it twice.
    // Because of stylefire's render batching, this isn't going
    // to actually render twice, but because we're making
    // the value jump a great distance, we want to reset the velocity
    // to 0, rather than something arbitrarily high
    var val = values.get(key).value;
    val.update(to);
    val.update(to);
  } else {
    values.set(key, { value: (0, _value2.default)(to, function (v) {
        return elementStyler.set(key, v);
      }) });
  }
};

var explicitlyFlipPose = function explicitlyFlipPose(state, nextPose) {
  var dimensions = state.dimensions,
      elementStyler = state.elementStyler;

  dimensions.measure();

  var width = nextPose.width,
      height = nextPose.height,
      top = nextPose.top,
      left = nextPose.left,
      bottom = nextPose.bottom,
      right = nextPose.right,
      remainingPose = _objectWithoutProperties(nextPose, ['width', 'height', 'top', 'left', 'bottom', 'right']);

  elementStyler.set({ width: width, height: height, top: top, left: left, bottom: bottom, right: right }).render();

  return implicitlyFlipPose(state, remainingPose);
};

var implicitlyFlipPose = function implicitlyFlipPose(state, nextPose) {
  var dimensions = state.dimensions,
      element = state.element,
      elementStyler = state.elementStyler;

  if (!dimensions.has()) return;

  var flipPose = {};
  var prev = dimensions.get();
  var next = element.getBoundingClientRect();

  if (prev.width !== next.width) {
    setValue(state, 'scaleX', prev.width / next.width);
    flipPose.scaleX = 1;
  }

  if (prev.height !== next.height) {
    setValue(state, 'scaleY', prev.height / next.height);
    flipPose.scaleY = 1;
  }

  var originX = prev.top === next.top ? 0 : prev.bottom === next.bottom ? '100%' : '50%';

  var originY = prev.left === next.left ? 0 : prev.right === next.right ? '100%' : '50%';

  // Here, if we already have the value, we update it twice.
  // Because of stylefire's render batching, this isn't going
  // to actually render twice, but because we're making
  // the value jump a great distance, we want to reset the velocity
  // to 0, rather than something arbitrarily high

  elementStyler.set({ originX: originX, originY: originY }).render();

  return _extends({}, nextPose, flipPose);
};

var flipPose = exports.flipPose = function flipPose(state, nextPose) {
  return hasPositionalProps(nextPose) ? explicitlyFlipPose(state, nextPose) : implicitlyFlipPose(state, nextPose);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mbGlwLmpzIl0sIm5hbWVzIjpbInBvc2l0aW9uYWxQcm9wcyIsIlNldCIsImNoZWNrUG9zaXRpb25hbFByb3AiLCJrZXkiLCJoYXMiLCJoYXNQb3NpdGlvbmFsUHJvcHMiLCJwb3NlIiwiT2JqZWN0Iiwia2V5cyIsInNvbWUiLCJpc0ZsaXBQb3NlIiwic2V0VmFsdWUiLCJ0byIsInZhbHVlcyIsImVsZW1lbnRTdHlsZXIiLCJ2YWwiLCJnZXQiLCJ2YWx1ZSIsInVwZGF0ZSIsInNldCIsInYiLCJleHBsaWNpdGx5RmxpcFBvc2UiLCJzdGF0ZSIsIm5leHRQb3NlIiwiZGltZW5zaW9ucyIsIm1lYXN1cmUiLCJ3aWR0aCIsImhlaWdodCIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInJlbWFpbmluZ1Bvc2UiLCJyZW5kZXIiLCJpbXBsaWNpdGx5RmxpcFBvc2UiLCJlbGVtZW50IiwiZmxpcFBvc2UiLCJwcmV2IiwibmV4dCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9yaWdpblgiLCJvcmlnaW5ZIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7O0FBRUEsSUFBTUEsa0JBQWtCLElBQUlDLEdBQUosQ0FBUSxDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLEtBQXBCLEVBQTJCLE1BQTNCLEVBQW1DLFFBQW5DLEVBQTZDLE9BQTdDLENBQVIsQ0FBeEI7QUFDQSxJQUFNQyxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFDQyxHQUFEO0FBQUEsU0FBU0gsZ0JBQWdCSSxHQUFoQixDQUFvQkQsR0FBcEIsQ0FBVDtBQUFBLENBQTVCO0FBQ0EsSUFBTUUscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBQ0MsSUFBRDtBQUFBLFNBQVVDLE9BQU9DLElBQVAsQ0FBWUYsSUFBWixFQUFrQkcsSUFBbEIsQ0FBdUJQLG1CQUF2QixDQUFWO0FBQUEsQ0FBM0I7QUFDTyxJQUFNUSxrQ0FBYSxTQUFiQSxVQUFhLENBQUNKLElBQUQsRUFBT0gsR0FBUDtBQUFBLFNBQWVFLG1CQUFtQkMsSUFBbkIsS0FBNEJILFFBQVEsTUFBbkQ7QUFBQSxDQUFuQjs7QUFFUCxJQUFNUSxXQUFXLFNBQVhBLFFBQVcsT0FBNEJSLEdBQTVCLEVBQWlDUyxFQUFqQyxFQUF3QztBQUFBLE1BQXJDQyxNQUFxQyxRQUFyQ0EsTUFBcUM7QUFBQSxNQUE3QkMsYUFBNkIsUUFBN0JBLGFBQTZCOztBQUN2RCxNQUFJRCxPQUFPVCxHQUFQLENBQVdELEdBQVgsQ0FBSixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTVksTUFBTUYsT0FBT0csR0FBUCxDQUFXYixHQUFYLEVBQWdCYyxLQUE1QjtBQUNBRixRQUFJRyxNQUFKLENBQVdOLEVBQVg7QUFDQUcsUUFBSUcsTUFBSixDQUFXTixFQUFYO0FBQ0QsR0FURCxNQVNPO0FBQ0xDLFdBQU9NLEdBQVAsQ0FBV2hCLEdBQVgsRUFBZ0IsRUFBRWMsT0FBTyxxQkFBTUwsRUFBTixFQUFVO0FBQUEsZUFBS0UsY0FBY0ssR0FBZCxDQUFrQmhCLEdBQWxCLEVBQXVCaUIsQ0FBdkIsQ0FBTDtBQUFBLE9BQVYsQ0FBVCxFQUFoQjtBQUNEO0FBQ0YsQ0FiRDs7QUFlQSxJQUFNQyxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFDQyxLQUFELEVBQVFDLFFBQVIsRUFBcUI7QUFBQSxNQUN0Q0MsVUFEc0MsR0FDUkYsS0FEUSxDQUN0Q0UsVUFEc0M7QUFBQSxNQUMxQlYsYUFEMEIsR0FDUlEsS0FEUSxDQUMxQlIsYUFEMEI7O0FBRTlDVSxhQUFXQyxPQUFYOztBQUY4QyxNQUd0Q0MsS0FIc0MsR0FHd0JILFFBSHhCLENBR3RDRyxLQUhzQztBQUFBLE1BRy9CQyxNQUgrQixHQUd3QkosUUFIeEIsQ0FHL0JJLE1BSCtCO0FBQUEsTUFHdkJDLEdBSHVCLEdBR3dCTCxRQUh4QixDQUd2QkssR0FIdUI7QUFBQSxNQUdsQkMsSUFIa0IsR0FHd0JOLFFBSHhCLENBR2xCTSxJQUhrQjtBQUFBLE1BR1pDLE1BSFksR0FHd0JQLFFBSHhCLENBR1pPLE1BSFk7QUFBQSxNQUdKQyxLQUhJLEdBR3dCUixRQUh4QixDQUdKUSxLQUhJO0FBQUEsTUFHTUMsYUFITiw0QkFHd0JULFFBSHhCOztBQUs5Q1QsZ0JBQ0dLLEdBREgsQ0FDTyxFQUFFTyxZQUFGLEVBQVNDLGNBQVQsRUFBaUJDLFFBQWpCLEVBQXNCQyxVQUF0QixFQUE0QkMsY0FBNUIsRUFBb0NDLFlBQXBDLEVBRFAsRUFFR0UsTUFGSDs7QUFJQSxTQUFPQyxtQkFBbUJaLEtBQW5CLEVBQTBCVSxhQUExQixDQUFQO0FBQ0QsQ0FWRDs7QUFZQSxJQUFNRSxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFDWixLQUFELEVBQVFDLFFBQVIsRUFBcUI7QUFBQSxNQUN0Q0MsVUFEc0MsR0FDQ0YsS0FERCxDQUN0Q0UsVUFEc0M7QUFBQSxNQUMxQlcsT0FEMEIsR0FDQ2IsS0FERCxDQUMxQmEsT0FEMEI7QUFBQSxNQUNqQnJCLGFBRGlCLEdBQ0NRLEtBREQsQ0FDakJSLGFBRGlCOztBQUU5QyxNQUFJLENBQUNVLFdBQVdwQixHQUFYLEVBQUwsRUFBdUI7O0FBRXZCLE1BQU1nQyxXQUFXLEVBQWpCO0FBQ0EsTUFBTUMsT0FBT2IsV0FBV1IsR0FBWCxFQUFiO0FBQ0EsTUFBTXNCLE9BQU9ILFFBQVFJLHFCQUFSLEVBQWI7O0FBRUEsTUFBSUYsS0FBS1gsS0FBTCxLQUFlWSxLQUFLWixLQUF4QixFQUErQjtBQUM3QmYsYUFBU1csS0FBVCxFQUFnQixRQUFoQixFQUEwQmUsS0FBS1gsS0FBTCxHQUFhWSxLQUFLWixLQUE1QztBQUNBVSxhQUFTSSxNQUFULEdBQWtCLENBQWxCO0FBQ0Q7O0FBRUQsTUFBSUgsS0FBS1YsTUFBTCxLQUFnQlcsS0FBS1gsTUFBekIsRUFBaUM7QUFDL0JoQixhQUFTVyxLQUFULEVBQWdCLFFBQWhCLEVBQTBCZSxLQUFLVixNQUFMLEdBQWNXLEtBQUtYLE1BQTdDO0FBQ0FTLGFBQVNLLE1BQVQsR0FBa0IsQ0FBbEI7QUFDRDs7QUFFRCxNQUFNQyxVQUFXTCxLQUFLVCxHQUFMLEtBQWFVLEtBQUtWLEdBQW5CLEdBQ1osQ0FEWSxHQUVYUyxLQUFLUCxNQUFMLEtBQWdCUSxLQUFLUixNQUF0QixHQUNFLE1BREYsR0FFRSxLQUpOOztBQU1BLE1BQU1hLFVBQVdOLEtBQUtSLElBQUwsS0FBY1MsS0FBS1QsSUFBcEIsR0FDWixDQURZLEdBRVhRLEtBQUtOLEtBQUwsS0FBZU8sS0FBS1AsS0FBckIsR0FDRSxNQURGLEdBRUUsS0FKTjs7QUFPTTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVOakIsZ0JBQ0dLLEdBREgsQ0FDTyxFQUFFdUIsZ0JBQUYsRUFBV0MsZ0JBQVgsRUFEUCxFQUVHVixNQUZIOztBQUlBLHNCQUNLVixRQURMLEVBRUthLFFBRkw7QUFJRCxDQTdDRDs7QUErQ08sSUFBTUEsOEJBQVcsU0FBWEEsUUFBVyxDQUFDZCxLQUFELEVBQVFDLFFBQVI7QUFBQSxTQUFxQmxCLG1CQUFtQmtCLFFBQW5CLElBQ3pDRixtQkFBbUJDLEtBQW5CLEVBQTBCQyxRQUExQixDQUR5QyxHQUV6Q1csbUJBQW1CWixLQUFuQixFQUEwQkMsUUFBMUIsQ0FGb0I7QUFBQSxDQUFqQiIsImZpbGUiOiJmbGlwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbHVlIGZyb20gJ3BvcG1vdGlvbi9yZWFjdGlvbnMvdmFsdWUnO1xuXG5jb25zdCBwb3NpdGlvbmFsUHJvcHMgPSBuZXcgU2V0KFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdsZWZ0JywgJ2JvdHRvbScsICdyaWdodCddKTtcbmNvbnN0IGNoZWNrUG9zaXRpb25hbFByb3AgPSAoa2V5KSA9PiBwb3NpdGlvbmFsUHJvcHMuaGFzKGtleSk7XG5jb25zdCBoYXNQb3NpdGlvbmFsUHJvcHMgPSAocG9zZSkgPT4gT2JqZWN0LmtleXMocG9zZSkuc29tZShjaGVja1Bvc2l0aW9uYWxQcm9wKTtcbmV4cG9ydCBjb25zdCBpc0ZsaXBQb3NlID0gKHBvc2UsIGtleSkgPT4gaGFzUG9zaXRpb25hbFByb3BzKHBvc2UpIHx8IGtleSA9PT0gJ2ZsaXAnO1xuXG5jb25zdCBzZXRWYWx1ZSA9ICh7IHZhbHVlcywgZWxlbWVudFN0eWxlciB9LCBrZXksIHRvKSA9PiB7XG4gIGlmICh2YWx1ZXMuaGFzKGtleSkpIHtcbiAgICAvLyBIZXJlLCBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHZhbHVlLCB3ZSB1cGRhdGUgaXQgdHdpY2UuXG4gICAgLy8gQmVjYXVzZSBvZiBzdHlsZWZpcmUncyByZW5kZXIgYmF0Y2hpbmcsIHRoaXMgaXNuJ3QgZ29pbmdcbiAgICAvLyB0byBhY3R1YWxseSByZW5kZXIgdHdpY2UsIGJ1dCBiZWNhdXNlIHdlJ3JlIG1ha2luZ1xuICAgIC8vIHRoZSB2YWx1ZSBqdW1wIGEgZ3JlYXQgZGlzdGFuY2UsIHdlIHdhbnQgdG8gcmVzZXQgdGhlIHZlbG9jaXR5XG4gICAgLy8gdG8gMCwgcmF0aGVyIHRoYW4gc29tZXRoaW5nIGFyYml0cmFyaWx5IGhpZ2hcbiAgICBjb25zdCB2YWwgPSB2YWx1ZXMuZ2V0KGtleSkudmFsdWU7XG4gICAgdmFsLnVwZGF0ZSh0byk7XG4gICAgdmFsLnVwZGF0ZSh0byk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzLnNldChrZXksIHsgdmFsdWU6IHZhbHVlKHRvLCB2ID0+IGVsZW1lbnRTdHlsZXIuc2V0KGtleSwgdikpIH0pO1xuICB9XG59O1xuXG5jb25zdCBleHBsaWNpdGx5RmxpcFBvc2UgPSAoc3RhdGUsIG5leHRQb3NlKSA9PiB7XG4gIGNvbnN0IHsgZGltZW5zaW9ucywgZWxlbWVudFN0eWxlciB9ID0gc3RhdGU7XG4gIGRpbWVuc2lvbnMubWVhc3VyZSgpO1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgLi4ucmVtYWluaW5nUG9zZSB9ID0gbmV4dFBvc2U7XG5cbiAgZWxlbWVudFN0eWxlclxuICAgIC5zZXQoeyB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSlcbiAgICAucmVuZGVyKCk7XG5cbiAgcmV0dXJuIGltcGxpY2l0bHlGbGlwUG9zZShzdGF0ZSwgcmVtYWluaW5nUG9zZSk7XG59O1xuXG5jb25zdCBpbXBsaWNpdGx5RmxpcFBvc2UgPSAoc3RhdGUsIG5leHRQb3NlKSA9PiB7XG4gIGNvbnN0IHsgZGltZW5zaW9ucywgZWxlbWVudCwgZWxlbWVudFN0eWxlciB9ID0gc3RhdGU7XG4gIGlmICghZGltZW5zaW9ucy5oYXMoKSkgcmV0dXJuO1xuXG4gIGNvbnN0IGZsaXBQb3NlID0ge307XG4gIGNvbnN0IHByZXYgPSBkaW1lbnNpb25zLmdldCgpO1xuICBjb25zdCBuZXh0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBpZiAocHJldi53aWR0aCAhPT0gbmV4dC53aWR0aCkge1xuICAgIHNldFZhbHVlKHN0YXRlLCAnc2NhbGVYJywgcHJldi53aWR0aCAvIG5leHQud2lkdGgpO1xuICAgIGZsaXBQb3NlLnNjYWxlWCA9IDE7XG4gIH1cblxuICBpZiAocHJldi5oZWlnaHQgIT09IG5leHQuaGVpZ2h0KSB7XG4gICAgc2V0VmFsdWUoc3RhdGUsICdzY2FsZVknLCBwcmV2LmhlaWdodCAvIG5leHQuaGVpZ2h0KTtcbiAgICBmbGlwUG9zZS5zY2FsZVkgPSAxO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luWCA9IChwcmV2LnRvcCA9PT0gbmV4dC50b3ApXG4gICAgPyAwXG4gICAgOiAocHJldi5ib3R0b20gPT09IG5leHQuYm90dG9tKVxuICAgICAgPyAnMTAwJSdcbiAgICAgIDogJzUwJSc7XG5cbiAgY29uc3Qgb3JpZ2luWSA9IChwcmV2LmxlZnQgPT09IG5leHQubGVmdClcbiAgICA/IDBcbiAgICA6IChwcmV2LnJpZ2h0ID09PSBuZXh0LnJpZ2h0KVxuICAgICAgPyAnMTAwJSdcbiAgICAgIDogJzUwJSc7XG5cblxuICAgICAgICAvLyBIZXJlLCBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHZhbHVlLCB3ZSB1cGRhdGUgaXQgdHdpY2UuXG4gICAgICAgIC8vIEJlY2F1c2Ugb2Ygc3R5bGVmaXJlJ3MgcmVuZGVyIGJhdGNoaW5nLCB0aGlzIGlzbid0IGdvaW5nXG4gICAgICAgIC8vIHRvIGFjdHVhbGx5IHJlbmRlciB0d2ljZSwgYnV0IGJlY2F1c2Ugd2UncmUgbWFraW5nXG4gICAgICAgIC8vIHRoZSB2YWx1ZSBqdW1wIGEgZ3JlYXQgZGlzdGFuY2UsIHdlIHdhbnQgdG8gcmVzZXQgdGhlIHZlbG9jaXR5XG4gICAgICAgIC8vIHRvIDAsIHJhdGhlciB0aGFuIHNvbWV0aGluZyBhcmJpdHJhcmlseSBoaWdoXG5cbiAgZWxlbWVudFN0eWxlclxuICAgIC5zZXQoeyBvcmlnaW5YLCBvcmlnaW5ZIH0pXG4gICAgLnJlbmRlcigpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ubmV4dFBvc2UsXG4gICAgLi4uZmxpcFBvc2VcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbGlwUG9zZSA9IChzdGF0ZSwgbmV4dFBvc2UpID0+IGhhc1Bvc2l0aW9uYWxQcm9wcyhuZXh0UG9zZSlcbiAgPyBleHBsaWNpdGx5RmxpcFBvc2Uoc3RhdGUsIG5leHRQb3NlKVxuICA6IGltcGxpY2l0bHlGbGlwUG9zZShzdGF0ZSwgbmV4dFBvc2UpOyJdfQ==