'use strict';

exports.__esModule = true;
exports.Dimensions = exports.makeDraggable = exports.createPoseSetter = exports.createValues = exports.createPoses = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _spring = require('popmotion/animations/spring');

var _spring2 = _interopRequireDefault(_spring);

var _tween = require('popmotion/animations/tween');

var _tween2 = _interopRequireDefault(_tween);

var _value = require('popmotion/reactions/value');

var _value2 = _interopRequireDefault(_value);

var _chain = require('popmotion/compositors/chain');

var _chain2 = _interopRequireDefault(_chain);

var _delay = require('popmotion/compositors/delay');

var _delay2 = _interopRequireDefault(_delay);

var _listen = require('popmotion/input/listen');

var _listen2 = _interopRequireDefault(_listen);

var _transformers = require('popmotion/transformers');

var _styleValueTypes = require('style-value-types');

var _actions = require('./actions');

var _utils = require('./utils');

var _flip = require('./flip');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var getPoses = function getPoses(_ref) {
  var draggable = _ref.draggable,
      initialPose = _ref.initialPose,
      passive = _ref.passive,
      onChange = _ref.onChange,
      dragBounds = _ref.dragBounds,
      onDragEnd = _ref.onDragEnd,
      onDragStart = _ref.onDragStart,
      parentValues = _ref.parentValues,
      poses = _objectWithoutProperties(_ref, ['draggable', 'initialPose', 'passive', 'onChange', 'dragBounds', 'onDragEnd', 'onDragStart', 'parentValues']);

  return poses;
};
var getDisplayProps = function getDisplayProps(_ref2) {
  var transition = _ref2.transition,
      delay = _ref2.delay,
      delayChildren = _ref2.delayChildren,
      staggerChildren = _ref2.staggerChildren,
      staggerDirection = _ref2.staggerDirection,
      props = _objectWithoutProperties(_ref2, ['transition', 'delay', 'delayChildren', 'staggerChildren', 'staggerDirection']);

  return props;
};

var underDampedSpring = function underDampedSpring(_ref3) {
  var from = _ref3.from,
      velocity = _ref3.velocity,
      to = _ref3.to;
  return (0, _spring2.default)({ from: from, to: to, velocity: velocity, stiffness: 500, damping: 25 });
};
var overDampedSpring = function overDampedSpring(_ref4) {
  var from = _ref4.from,
      velocity = _ref4.velocity,
      to = _ref4.to;
  return (0, _spring2.default)({ from: from, to: to, velocity: velocity, stiffness: 700, damping: 35 });
};
var defaultTransitions = new Map([['default', (0, _utils.transitionProps)({
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  scaleX: overDampedSpring,
  scaleY: overDampedSpring,
  scale: overDampedSpring,
  default: _tween2.default
})], ['dragging', function (_ref5) {
  var key = _ref5.key,
      from = _ref5.from;
  return key === 'y' ? (0, _actions.pointerY)(from) : (0, _actions.pointerX)(from);
}], ['dragEnd', function (_ref6) {
  var from = _ref6.from;
  return (0, _actions.just)(from);
}]]);

var buildPoseMap = function buildPoseMap(poseMap, _ref7) {
  var key = _ref7[0],
      pose = _ref7[1];

  poseMap[key] = _extends({
    transition: defaultTransitions.has(key) ? defaultTransitions.get(key) : defaultTransitions.get('default')
  }, pose);
  return poseMap;
};

var createPoses = exports.createPoses = function createPoses(props) {
  var poses = getPoses(props);
  var draggable = props.draggable;


  if (draggable) {
    var dragging = {};
    var dragEnd = {};

    if (draggable === true || draggable === 'x') dragging.x = dragEnd.x = true;
    if (draggable === true || draggable === 'y') dragging.y = dragEnd.y = true;

    poses = _extends({
      dragging: dragging,
      dragEnd: dragEnd
    }, poses);
  }

  poses = _extends({
    flip: {}
  }, poses);

  return Object.entries(poses).reduce(buildPoseMap, {});
};

var boundaryMap = {
  x: ['left', 'right'],
  y: ['top', 'bottom'],
  z: ['far', 'near']
};
var addBoundaries = function addBoundaries(a, bounds, key) {
  var enforceBounds = [];
  var _boundaryMap$key = boundaryMap[key],
      min = _boundaryMap$key[0],
      max = _boundaryMap$key[1];


  if (bounds[min] !== undefined) enforceBounds.push(function (v) {
    return Math.max(v, bounds[min]);
  });
  if (bounds[max] !== undefined) enforceBounds.push(function (v) {
    return Math.min(v, bounds[max]);
  });

  return enforceBounds.length ? a.pipe.apply(a, enforceBounds) : a;
};

var valueTypeTests = [_styleValueTypes.number, _styleValueTypes.degrees, _styleValueTypes.percent, _styleValueTypes.px];
var testValueType = function testValueType(v) {
  return function (type) {
    return type.test(v);
  };
};
var createValues = exports.createValues = function createValues(_ref8) {
  var poses = _ref8.poses,
      styler = _ref8.styler,
      initialPose = _ref8.initialPose,
      passive = _ref8.passive,
      parentValues = _ref8.parentValues,
      onChange = _ref8.onChange;

  var values = new Map();

  // Scrape values from poses
  Object.keys(poses).reduce(function (valueMap, poseKey) {
    var pose = poses[poseKey];

    Object.keys(getDisplayProps(pose)).forEach(function (key) {
      if (valueMap.has(key)) return;

      var type = valueTypeTests.find(testValueType(pose[key]));

      // If there's an initial pose defined, set the value to that, otherwise attempt to read from the element
      var unparsedInitialValue = initialPose && poses[initialPose] && poses[initialPose][key] !== undefined ? poses[initialPose][key] : styler.get(key);
      var initialValue = type ? type.parse(unparsedInitialValue) : unparsedInitialValue;
      var val = (0, _value2.default)(initialValue);

      // Convert to value type
      if (type) val = val.pipe(type.transform);

      // Bind styler setter to value updates
      val.subscribe(styler.set(key));

      valueMap.set(key, { value: val, type: type });
    });

    return valueMap;
  }, values);

  // Initiate passive values
  if (passive) {
    Object.keys(passive).forEach(function (key) {
      var _passive$key = passive[key],
          valueKey = _passive$key[0],
          transform = _passive$key[1],
          fromParent = _passive$key[2];

      var valueToBind = fromParent && parentValues && parentValues.has(valueKey) ? parentValues.get(valueKey).value : values.has(valueKey) ? values.get(valueKey).value : false;

      if (!valueToBind) return;

      // Maybe make a new value here
      var newValue = (0, _value2.default)(valueToBind.get(), (0, _transformers.pipe)(transform, styler.set(key)));
      valueToBind.subscribe(newValue);
      values.set({ value: valueToBind });
    });
  }

  // Append onChange callbacks
  if (onChange) {
    Object.keys(onChange).forEach(function (key) {
      if (values.has(key)) values.get(key).value.subscribe(onChange[key]);
    });
  }

  return values;
};

var childAnimations = function childAnimations(children, nextPoseKey, nextPose, props) {
  var animations = [];
  var delay = 0;
  var stagger = 0;
  var staggerDirection = 1;

  if (nextPose) {
    delay = nextPose.delayChildren || delay;
    stagger = nextPose.staggerChildren || stagger;
    staggerDirection = nextPose.staggerDirection || staggerDirection;
  }

  var maxStaggerDuration = children.length - 1 * stagger;
  var generateStaggerDuration = staggerDirection === 1 ? function (i) {
    return i * stagger;
  } : function (i) {
    return maxStaggerDuration - i * stagger;
  };

  Array.from(children).forEach(function (child, i) {
    if (child.has(nextPoseKey)) {
      animations.push(child.set(nextPoseKey, _extends({}, props, {
        delay: delay + generateStaggerDuration(i)
      })));
    }
  });

  return animations;
};

var dragPoses = new Set(['dragging', 'dragEnd']);
var createPoseSetter = exports.createPoseSetter = function createPoseSetter(state) {
  return function (next) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _props$delay = props.delay,
        delay = _props$delay === undefined ? 0 : _props$delay;
    var activeActions = state.activeActions,
        children = state.children,
        poses = state.poses,
        values = state.values,
        dragProps = state.dragProps;

    var animations = [];
    var nextPose = poses[next];

    // Grab the animations for this poser
    if (nextPose) {
      if ((0, _flip.isFlipPose)(nextPose, next)) nextPose = (0, _flip.flipPose)(state, nextPose);

      var poserAnimations = nextPose && Object.keys(getDisplayProps(nextPose)).map(function (key) {
        return new Promise(function (complete) {
          var _nextPose = nextPose,
              getTransition = _nextPose.transition;

          var _values$get = values.get(key),
              thisVal = _values$get.value,
              type = _values$get.type;

          var from = thisVal.get();

          if (activeActions.has(key)) activeActions.get(key).stop();

          var transition = getTransition !== false ? getTransition(_extends({}, props, {
            from: type ? type.parse(from) : from,
            velocity: thisVal.getVelocity() || 0,
            to: type ? type.parse(nextPose[key]) : nextPose[key],
            key: key,
            prevPoseKey: poses[key]
          })) : (0, _actions.just)(nextPose[key]);

          if (dragPoses.has(next) && dragProps.bounds && boundaryMap[key]) transition = addBoundaries(transition, dragProps.bounds, key);

          if (delay || nextPose.delay) transition = (0, _chain2.default)((0, _delay2.default)(delay || nextPose.delay), transition);

          var transitionApi = transition.start({
            update: function update(v) {
              return thisVal.update(v);
            },
            complete: complete
          });

          activeActions.set(key, transitionApi);
          poses[key] = next;
        });
      });

      animations.push.apply(animations, poserAnimations);
    }

    // Children animations
    if (children.size) animations.push.apply(animations, childAnimations(children, next, nextPose, props));

    return Promise.all(animations);
  };
};

var makeDraggable = exports.makeDraggable = function makeDraggable(element, set, activeActions) {
  var _ref9 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      onDragStart = _ref9.onDragStart,
      onDragEnd = _ref9.onDragEnd;

  return activeActions.set('dragStartListener', (0, _listen2.default)(element, 'mousedown touchstart').start(function (e) {
    e.preventDefault();
    set('dragging');
    if (onDragStart) onDragStart(e);

    activeActions.set('dragEndListener', (0, _listen2.default)(document, 'mouseup touchend').start(function () {
      activeActions.get('dragEndListener').stop();
      set('dragEnd');
      if (onDragEnd) onDragEnd(e);
    }));
  }));
};

var Dimensions = exports.Dimensions = function () {
  function Dimensions(element) {
    _classCallCheck(this, Dimensions);

    this.current = {};
    this.element = element;
  }

  Dimensions.prototype.get = function get() {
    return this.current;
  };

  Dimensions.prototype.measure = function measure() {
    this.current = this.element.getBoundingClientRect();
  };

  Dimensions.prototype.has = function has() {
    return this.current.width !== undefined;
  };

  return Dimensions;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mYWN0b3JpZXMuanMiXSwibmFtZXMiOlsiZ2V0UG9zZXMiLCJkcmFnZ2FibGUiLCJpbml0aWFsUG9zZSIsInBhc3NpdmUiLCJvbkNoYW5nZSIsImRyYWdCb3VuZHMiLCJvbkRyYWdFbmQiLCJvbkRyYWdTdGFydCIsInBhcmVudFZhbHVlcyIsInBvc2VzIiwiZ2V0RGlzcGxheVByb3BzIiwidHJhbnNpdGlvbiIsImRlbGF5IiwiZGVsYXlDaGlsZHJlbiIsInN0YWdnZXJDaGlsZHJlbiIsInN0YWdnZXJEaXJlY3Rpb24iLCJwcm9wcyIsInVuZGVyRGFtcGVkU3ByaW5nIiwiZnJvbSIsInZlbG9jaXR5IiwidG8iLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwib3ZlckRhbXBlZFNwcmluZyIsImRlZmF1bHRUcmFuc2l0aW9ucyIsIk1hcCIsIngiLCJ5IiwieiIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlIiwiZGVmYXVsdCIsImtleSIsImJ1aWxkUG9zZU1hcCIsInBvc2VNYXAiLCJwb3NlIiwiaGFzIiwiZ2V0IiwiY3JlYXRlUG9zZXMiLCJkcmFnZ2luZyIsImRyYWdFbmQiLCJmbGlwIiwiT2JqZWN0IiwiZW50cmllcyIsInJlZHVjZSIsImJvdW5kYXJ5TWFwIiwiYWRkQm91bmRhcmllcyIsImEiLCJib3VuZHMiLCJlbmZvcmNlQm91bmRzIiwibWluIiwibWF4IiwidW5kZWZpbmVkIiwicHVzaCIsIk1hdGgiLCJ2IiwibGVuZ3RoIiwicGlwZSIsInZhbHVlVHlwZVRlc3RzIiwidGVzdFZhbHVlVHlwZSIsInR5cGUiLCJ0ZXN0IiwiY3JlYXRlVmFsdWVzIiwic3R5bGVyIiwidmFsdWVzIiwia2V5cyIsInZhbHVlTWFwIiwicG9zZUtleSIsImZvckVhY2giLCJmaW5kIiwidW5wYXJzZWRJbml0aWFsVmFsdWUiLCJpbml0aWFsVmFsdWUiLCJwYXJzZSIsInZhbCIsInRyYW5zZm9ybSIsInN1YnNjcmliZSIsInNldCIsInZhbHVlIiwidmFsdWVLZXkiLCJmcm9tUGFyZW50IiwidmFsdWVUb0JpbmQiLCJuZXdWYWx1ZSIsImNoaWxkQW5pbWF0aW9ucyIsImNoaWxkcmVuIiwibmV4dFBvc2VLZXkiLCJuZXh0UG9zZSIsImFuaW1hdGlvbnMiLCJzdGFnZ2VyIiwibWF4U3RhZ2dlckR1cmF0aW9uIiwiZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24iLCJpIiwiQXJyYXkiLCJjaGlsZCIsImRyYWdQb3NlcyIsIlNldCIsImNyZWF0ZVBvc2VTZXR0ZXIiLCJzdGF0ZSIsIm5leHQiLCJhY3RpdmVBY3Rpb25zIiwiZHJhZ1Byb3BzIiwicG9zZXJBbmltYXRpb25zIiwibWFwIiwiUHJvbWlzZSIsImdldFRyYW5zaXRpb24iLCJ0aGlzVmFsIiwic3RvcCIsImdldFZlbG9jaXR5IiwicHJldlBvc2VLZXkiLCJ0cmFuc2l0aW9uQXBpIiwic3RhcnQiLCJ1cGRhdGUiLCJjb21wbGV0ZSIsInNpemUiLCJhbGwiLCJtYWtlRHJhZ2dhYmxlIiwiZWxlbWVudCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImRvY3VtZW50IiwiRGltZW5zaW9ucyIsImN1cnJlbnQiLCJtZWFzdXJlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNQSxXQUFXLFNBQVhBLFFBQVc7QUFBQSxNQUFHQyxTQUFILFFBQUdBLFNBQUg7QUFBQSxNQUFjQyxXQUFkLFFBQWNBLFdBQWQ7QUFBQSxNQUEyQkMsT0FBM0IsUUFBMkJBLE9BQTNCO0FBQUEsTUFBb0NDLFFBQXBDLFFBQW9DQSxRQUFwQztBQUFBLE1BQThDQyxVQUE5QyxRQUE4Q0EsVUFBOUM7QUFBQSxNQUEwREMsU0FBMUQsUUFBMERBLFNBQTFEO0FBQUEsTUFBcUVDLFdBQXJFLFFBQXFFQSxXQUFyRTtBQUFBLE1BQWtGQyxZQUFsRixRQUFrRkEs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RCxDQUY2RixDQUFsRTtBQUFBLENBQXRCOztJQWtCTUcsVSxXQUFBQSxVO0FBQ1gsc0JBQVlKLE9BQVosRUFBcUI7QUFBQTs7QUFDbkIsU0FBS0ssT0FBTCxHQUFlLEVBQWY7QUFDQSxTQUFLTCxPQUFMLEdBQWVBLE9BQWY7QUFDRDs7dUJBRUQ5RSxHLGtCQUFNO0FBQ0osV0FBTyxLQUFLbUYsT0FBWjtBQUNELEc7O3VCQUVEQyxPLHNCQUFVO0FBQ1IsU0FBS0QsT0FBTCxHQUFlLEtBQUtMLE9BQUwsQ0FBYU8scUJBQWIsRUFBZjtBQUNELEc7O3VCQUVEdEYsRyxrQkFBTTtBQUNKLFdBQU8sS0FBS29GLE9BQUwsQ0FBYUcsS0FBYixLQUF1QnZFLFNBQTlCO0FBQ0QsRyIsImZpbGUiOiJmYWN0b3JpZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3ByaW5nIGZyb20gJ3BvcG1vdGlvbi9hbmltYXRpb25zL3NwcmluZyc7XG5pbXBvcnQgdHdlZW4gZnJvbSAncG9wbW90aW9uL2FuaW1hdGlvbnMvdHdlZW4nXG5pbXBvcnQgdmFsdWUgZnJvbSAncG9wbW90aW9uL3JlYWN0aW9ucy92YWx1ZSc7XG5pbXBvcnQgY2hhaW4gZnJvbSAncG9wbW90aW9uL2NvbXBvc2l0b3JzL2NoYWluJztcbmltcG9ydCBkZWxheUFjdGlvbiBmcm9tICdwb3Btb3Rpb24vY29tcG9zaXRvcnMvZGVsYXknO1xuaW1wb3J0IGxpc3RlbiBmcm9tICdwb3Btb3Rpb24vaW5wdXQvbGlzdGVuJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICdwb3Btb3Rpb24vdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7IG51bWJlciwgZGVncmVlcywgcGVyY2VudCwgcHggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBwb2ludGVyWCwgcG9pbnRlclksIGp1c3QgfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHsgdHJhbnNpdGlvblByb3BzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBmbGlwUG9zZSwgaXNGbGlwUG9zZSB9IGZyb20gJy4vZmxpcCc7XG5cbmNvbnN0IGdldFBvc2VzID0gKHsgZHJhZ2dhYmxlLCBpbml0aWFsUG9zZSwgcGFzc2l2ZSwgb25DaGFuZ2UsIGRyYWdCb3VuZHMsIG9uRHJhZ0VuZCwgb25EcmFnU3RhcnQsIHBhcmVudFZhbHVlcywgLi4ucG9zZXMgfSkgPT4gcG9zZXM7XG5jb25zdCBnZXREaXNwbGF5UHJvcHMgPSAoeyB0cmFuc2l0aW9uLCBkZWxheSwgZGVsYXlDaGlsZHJlbiwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCAuLi5wcm9wcyB9KSA9PiBwcm9wcztcblxuY29uc3QgdW5kZXJEYW1wZWRTcHJpbmcgPSAoeyBmcm9tLCB2ZWxvY2l0eSwgdG8gfSkgPT4gc3ByaW5nKHsgZnJvbSwgdG8sIHZlbG9jaXR5LCBzdGlmZm5lc3M6IDUwMCwgZGFtcGluZzogMjUgfSk7XG5jb25zdCBvdmVyRGFtcGVkU3ByaW5nID0gKHsgZnJvbSwgdmVsb2NpdHksIHRvIH0pID0+IHNwcmluZyh7IGZyb20sIHRvLCB2ZWxvY2l0eSwgc3RpZmZuZXNzOiA3MDAsIGRhbXBpbmc6IDM1IH0pO1xuY29uc3QgZGVmYXVsdFRyYW5zaXRpb25zID0gbmV3IE1hcChbXG4gIFsnZGVmYXVsdCcsIHRyYW5zaXRpb25Qcm9wcyh7XG4gICAgeDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgeTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgejogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgc2NhbGVYOiBvdmVyRGFtcGVkU3ByaW5nLFxuICAgIHNjYWxlWTogb3ZlckRhbXBlZFNwcmluZyxcbiAgICBzY2FsZTogb3ZlckRhbXBlZFNwcmluZyxcbiAgICBkZWZhdWx0OiB0d2VlblxuICB9KV0sXG4gIFsnZHJhZ2dpbmcnLCAoeyBrZXksIGZyb20gfSkgPT4ga2V5ID09PSAneScgPyBwb2ludGVyWShmcm9tKSA6IHBvaW50ZXJYKGZyb20pXSxcbiAgWydkcmFnRW5kJywgKHsgZnJvbSB9KSA9PiBqdXN0KGZyb20pXVxuXSk7XG5cbmNvbnN0IGJ1aWxkUG9zZU1hcCA9IChwb3NlTWFwLCBba2V5LCBwb3NlXSkgPT4ge1xuICBwb3NlTWFwW2tleV0gPSB7XG4gICAgdHJhbnNpdGlvbjogZGVmYXVsdFRyYW5zaXRpb25zLmhhcyhrZXkpXG4gICAgICA/IGRlZmF1bHRUcmFuc2l0aW9ucy5nZXQoa2V5KVxuICAgICAgOiBkZWZhdWx0VHJhbnNpdGlvbnMuZ2V0KCdkZWZhdWx0JyksXG4gICAgLi4ucG9zZVxuICB9O1xuICByZXR1cm4gcG9zZU1hcDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQb3NlcyA9IChwcm9wcykgPT4ge1xuICBsZXQgcG9zZXMgPSBnZXRQb3Nlcyhwcm9wcyk7XG4gIGNvbnN0IHsgZHJhZ2dhYmxlIH0gPSBwcm9wcztcblxuICBpZiAoZHJhZ2dhYmxlKSB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB7fTtcbiAgICBjb25zdCBkcmFnRW5kID0ge307XG5cbiAgICBpZiAoZHJhZ2dhYmxlID09PSB0cnVlIHx8IGRyYWdnYWJsZSA9PT0gJ3gnKSBkcmFnZ2luZy54ID0gZHJhZ0VuZC54ID0gdHJ1ZTtcbiAgICBpZiAoZHJhZ2dhYmxlID09PSB0cnVlIHx8IGRyYWdnYWJsZSA9PT0gJ3knKSBkcmFnZ2luZy55ID0gZHJhZ0VuZC55ID0gdHJ1ZTtcblxuICAgIHBvc2VzID0ge1xuICAgICAgZHJhZ2dpbmcsXG4gICAgICBkcmFnRW5kLFxuICAgICAgLi4ucG9zZXNcbiAgICB9O1xuICB9XG5cbiAgcG9zZXMgPSB7XG4gICAgZmxpcDoge30sXG4gICAgLi4ucG9zZXNcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocG9zZXMpLnJlZHVjZShidWlsZFBvc2VNYXAsIHt9KTtcbn07XG5cbmNvbnN0IGJvdW5kYXJ5TWFwID0ge1xuICB4OiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgeTogWyd0b3AnLCAnYm90dG9tJ10sXG4gIHo6IFsnZmFyJywgJ25lYXInXVxufTtcbmNvbnN0IGFkZEJvdW5kYXJpZXMgPSAoYSwgYm91bmRzLCBrZXkpID0+IHtcbiAgY29uc3QgZW5mb3JjZUJvdW5kcyA9IFtdO1xuICBjb25zdCBbbWluLCBtYXhdID0gYm91bmRhcnlNYXBba2V5XTtcblxuICBpZiAoYm91bmRzW21pbl0gIT09IHVuZGVmaW5lZCkgZW5mb3JjZUJvdW5kcy5wdXNoKHYgPT4gTWF0aC5tYXgodiwgYm91bmRzW21pbl0pKTtcbiAgaWYgKGJvdW5kc1ttYXhdICE9PSB1bmRlZmluZWQpIGVuZm9yY2VCb3VuZHMucHVzaCh2ID0+IE1hdGgubWluKHYsIGJvdW5kc1ttYXhdKSk7XG5cbiAgcmV0dXJuIGVuZm9yY2VCb3VuZHMubGVuZ3RoID8gYS5waXBlKC4uLmVuZm9yY2VCb3VuZHMpIDogYTtcbn07IFxuXG5jb25zdCB2YWx1ZVR5cGVUZXN0cyA9IFtudW1iZXIsIGRlZ3JlZXMsIHBlcmNlbnQsIHB4XTtcbmNvbnN0IHRlc3RWYWx1ZVR5cGUgPSB2ID0+IHR5cGUgPT4gdHlwZS50ZXN0KHYpO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZhbHVlcyA9ICh7IHBvc2VzLCBzdHlsZXIsIGluaXRpYWxQb3NlLCBwYXNzaXZlLCBwYXJlbnRWYWx1ZXMsIG9uQ2hhbmdlIH0pID0+IHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gIC8vIFNjcmFwZSB2YWx1ZXMgZnJvbSBwb3Nlc1xuICBPYmplY3Qua2V5cyhwb3NlcykucmVkdWNlKCh2YWx1ZU1hcCwgcG9zZUtleSkgPT4ge1xuICAgIGNvbnN0IHBvc2UgPSBwb3Nlc1twb3NlS2V5XTtcblxuICAgIE9iamVjdC5rZXlzKGdldERpc3BsYXlQcm9wcyhwb3NlKSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAodmFsdWVNYXAuaGFzKGtleSkpIHJldHVybjtcbiAgXG4gICAgICBjb25zdCB0eXBlID0gdmFsdWVUeXBlVGVzdHMuZmluZCh0ZXN0VmFsdWVUeXBlKHBvc2Vba2V5XSkpO1xuICBcbiAgICAgIC8vIElmIHRoZXJlJ3MgYW4gaW5pdGlhbCBwb3NlIGRlZmluZWQsIHNldCB0aGUgdmFsdWUgdG8gdGhhdCwgb3RoZXJ3aXNlIGF0dGVtcHQgdG8gcmVhZCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICBjb25zdCB1bnBhcnNlZEluaXRpYWxWYWx1ZSA9IChpbml0aWFsUG9zZSAmJiBwb3Nlc1tpbml0aWFsUG9zZV0gJiYgcG9zZXNbaW5pdGlhbFBvc2VdW2tleV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBwb3Nlc1tpbml0aWFsUG9zZV1ba2V5XVxuICAgICAgICA6IHN0eWxlci5nZXQoa2V5KTtcbiAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IHR5cGUgPyB0eXBlLnBhcnNlKHVucGFyc2VkSW5pdGlhbFZhbHVlKSA6IHVucGFyc2VkSW5pdGlhbFZhbHVlO1xuICAgICAgbGV0IHZhbCA9IHZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gIFxuICAgICAgLy8gQ29udmVydCB0byB2YWx1ZSB0eXBlXG4gICAgICBpZiAodHlwZSkgdmFsID0gdmFsLnBpcGUodHlwZS50cmFuc2Zvcm0pO1xuICBcbiAgICAgIC8vIEJpbmQgc3R5bGVyIHNldHRlciB0byB2YWx1ZSB1cGRhdGVzXG4gICAgICB2YWwuc3Vic2NyaWJlKHN0eWxlci5zZXQoa2V5KSk7XG4gIFxuICAgICAgdmFsdWVNYXAuc2V0KGtleSwgeyB2YWx1ZTogdmFsLCB0eXBlIH0pO1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gdmFsdWVNYXA7XG4gIH0sIHZhbHVlcyk7XG5cbiAgLy8gSW5pdGlhdGUgcGFzc2l2ZSB2YWx1ZXNcbiAgaWYgKHBhc3NpdmUpIHtcbiAgICBPYmplY3Qua2V5cyhwYXNzaXZlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBbdmFsdWVLZXksIHRyYW5zZm9ybSwgZnJvbVBhcmVudF0gPSBwYXNzaXZlW2tleV07XG4gICAgICBjb25zdCB2YWx1ZVRvQmluZCA9IChmcm9tUGFyZW50ICYmIHBhcmVudFZhbHVlcyAmJiBwYXJlbnRWYWx1ZXMuaGFzKHZhbHVlS2V5KSlcbiAgICAgICAgPyBwYXJlbnRWYWx1ZXMuZ2V0KHZhbHVlS2V5KS52YWx1ZVxuICAgICAgICA6ICh2YWx1ZXMuaGFzKHZhbHVlS2V5KSlcbiAgICAgICAgICA/IHZhbHVlcy5nZXQodmFsdWVLZXkpLnZhbHVlXG4gICAgICAgICAgOiBmYWxzZTtcblxuICAgICAgaWYgKCF2YWx1ZVRvQmluZCkgcmV0dXJuO1xuXG4gICAgICAvLyBNYXliZSBtYWtlIGEgbmV3IHZhbHVlIGhlcmVcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUodmFsdWVUb0JpbmQuZ2V0KCksIHBpcGUodHJhbnNmb3JtLCBzdHlsZXIuc2V0KGtleSkpKTtcbiAgICAgIHZhbHVlVG9CaW5kLnN1YnNjcmliZShuZXdWYWx1ZSk7XG4gICAgICB2YWx1ZXMuc2V0KHsgdmFsdWU6IHZhbHVlVG9CaW5kIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQXBwZW5kIG9uQ2hhbmdlIGNhbGxiYWNrc1xuICBpZiAob25DaGFuZ2UpIHtcbiAgICBPYmplY3Qua2V5cyhvbkNoYW5nZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHZhbHVlcy5oYXMoa2V5KSkgdmFsdWVzLmdldChrZXkpLnZhbHVlLnN1YnNjcmliZShvbkNoYW5nZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG5jb25zdCBjaGlsZEFuaW1hdGlvbnMgPSAoY2hpbGRyZW4sIG5leHRQb3NlS2V5LCBuZXh0UG9zZSwgcHJvcHMpID0+IHtcbiAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICBsZXQgZGVsYXkgPSAwO1xuICBsZXQgc3RhZ2dlciA9IDA7XG4gIGxldCBzdGFnZ2VyRGlyZWN0aW9uID0gMTtcblxuICBpZiAobmV4dFBvc2UpIHtcbiAgICBkZWxheSA9IG5leHRQb3NlLmRlbGF5Q2hpbGRyZW4gfHwgZGVsYXk7XG4gICAgc3RhZ2dlciA9IG5leHRQb3NlLnN0YWdnZXJDaGlsZHJlbiB8fCBzdGFnZ2VyO1xuICAgIHN0YWdnZXJEaXJlY3Rpb24gPSBuZXh0UG9zZS5zdGFnZ2VyRGlyZWN0aW9uIHx8IHN0YWdnZXJEaXJlY3Rpb247XG4gIH1cblxuICBjb25zdCBtYXhTdGFnZ2VyRHVyYXRpb24gPSBjaGlsZHJlbi5sZW5ndGggLSAxICogc3RhZ2dlcjtcbiAgY29uc3QgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxXG4gICAgPyBpID0+IGkgKiBzdGFnZ2VyXG4gICAgOiBpID0+IG1heFN0YWdnZXJEdXJhdGlvbiAtIChpICogc3RhZ2dlcik7XG5cbiAgQXJyYXkuZnJvbShjaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICBpZiAoY2hpbGQuaGFzKG5leHRQb3NlS2V5KSkge1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGNoaWxkLnNldChuZXh0UG9zZUtleSwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgZGVsYXk6IGRlbGF5ICsgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24oaSlcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhbmltYXRpb25zO1xufTtcblxuY29uc3QgZHJhZ1Bvc2VzID0gbmV3IFNldChbJ2RyYWdnaW5nJywgJ2RyYWdFbmQnXSk7XG5leHBvcnQgY29uc3QgY3JlYXRlUG9zZVNldHRlciA9IChzdGF0ZSkgPT4gKG5leHQsIHByb3BzID0ge30pID0+IHtcbiAgY29uc3QgeyBkZWxheSA9IDAgfSA9IHByb3BzO1xuICBjb25zdCB7IGFjdGl2ZUFjdGlvbnMsIGNoaWxkcmVuLCBwb3NlcywgdmFsdWVzLCBkcmFnUHJvcHMgfSA9IHN0YXRlO1xuICBjb25zdCBhbmltYXRpb25zID0gW107XG4gIGxldCBuZXh0UG9zZSA9IHBvc2VzW25leHRdO1xuXG4gIC8vIEdyYWIgdGhlIGFuaW1hdGlvbnMgZm9yIHRoaXMgcG9zZXJcbiAgaWYgKG5leHRQb3NlKSB7XG4gICAgaWYgKGlzRmxpcFBvc2UobmV4dFBvc2UsIG5leHQpKSBuZXh0UG9zZSA9IGZsaXBQb3NlKHN0YXRlLCBuZXh0UG9zZSk7XG5cbiAgICBjb25zdCBwb3NlckFuaW1hdGlvbnMgPSBuZXh0UG9zZSAmJiBPYmplY3Qua2V5cyhnZXREaXNwbGF5UHJvcHMobmV4dFBvc2UpKS5tYXAoXG4gICAgICBrZXkgPT4gbmV3IFByb21pc2UoY29tcGxldGUgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zaXRpb246IGdldFRyYW5zaXRpb24gfSA9IG5leHRQb3NlO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiB0aGlzVmFsLCB0eXBlIH0gPSB2YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0aGlzVmFsLmdldCgpO1xuXG4gICAgICAgIGlmIChhY3RpdmVBY3Rpb25zLmhhcyhrZXkpKSBhY3RpdmVBY3Rpb25zLmdldChrZXkpLnN0b3AoKTtcblxuICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IChnZXRUcmFuc2l0aW9uICE9PSBmYWxzZSlcbiAgICAgICAgICA/IGdldFRyYW5zaXRpb24oe1xuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBmcm9tOiB0eXBlID8gdHlwZS5wYXJzZShmcm9tKSA6IGZyb20sXG4gICAgICAgICAgICB2ZWxvY2l0eTogdGhpc1ZhbC5nZXRWZWxvY2l0eSgpIHx8IDAsXG4gICAgICAgICAgICB0bzogdHlwZSA/IHR5cGUucGFyc2UobmV4dFBvc2Vba2V5XSkgOiBuZXh0UG9zZVtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcHJldlBvc2VLZXk6IHBvc2VzW2tleV1cbiAgICAgICAgICB9KVxuICAgICAgICAgIDoganVzdChuZXh0UG9zZVtrZXldKTtcblxuICAgICAgICBpZiAoZHJhZ1Bvc2VzLmhhcyhuZXh0KSAmJiBkcmFnUHJvcHMuYm91bmRzICYmIGJvdW5kYXJ5TWFwW2tleV0pIHRyYW5zaXRpb24gPSBhZGRCb3VuZGFyaWVzKHRyYW5zaXRpb24sIGRyYWdQcm9wcy5ib3VuZHMsIGtleSk7XG5cbiAgICAgICAgaWYgKGRlbGF5IHx8IG5leHRQb3NlLmRlbGF5KSB0cmFuc2l0aW9uID0gY2hhaW4oXG4gICAgICAgICAgZGVsYXlBY3Rpb24oZGVsYXkgfHwgbmV4dFBvc2UuZGVsYXkpLFxuICAgICAgICAgIHRyYW5zaXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uQXBpID0gdHJhbnNpdGlvbi5zdGFydCh7XG4gICAgICAgICAgdXBkYXRlOiB2ID0+IHRoaXNWYWwudXBkYXRlKHYpLFxuICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFjdGl2ZUFjdGlvbnMuc2V0KGtleSwgdHJhbnNpdGlvbkFwaSk7XG4gICAgICAgIHBvc2VzW2tleV0gPSBuZXh0O1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgYW5pbWF0aW9ucy5wdXNoKC4uLnBvc2VyQW5pbWF0aW9ucyk7XG4gIH1cblxuICAvLyBDaGlsZHJlbiBhbmltYXRpb25zXG4gIGlmIChjaGlsZHJlbi5zaXplKSBhbmltYXRpb25zLnB1c2goLi4uY2hpbGRBbmltYXRpb25zKGNoaWxkcmVuLCBuZXh0LCBuZXh0UG9zZSwgcHJvcHMpKTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG59O1xuXG5leHBvcnQgY29uc3QgbWFrZURyYWdnYWJsZSA9IChlbGVtZW50LCBzZXQsIGFjdGl2ZUFjdGlvbnMsIHsgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCB9ID0ge30pID0+IGFjdGl2ZUFjdGlvbnMuc2V0KFxuICAnZHJhZ1N0YXJ0TGlzdGVuZXInLFxuICBsaXN0ZW4oZWxlbWVudCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0Jykuc3RhcnQoKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgc2V0KCdkcmFnZ2luZycpO1xuICAgIGlmIChvbkRyYWdTdGFydCkgb25EcmFnU3RhcnQoZSk7XG5cbiAgICBhY3RpdmVBY3Rpb25zLnNldChcbiAgICAgICdkcmFnRW5kTGlzdGVuZXInLFxuICAgICAgbGlzdGVuKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCcpLnN0YXJ0KCgpID0+IHtcbiAgICAgICAgYWN0aXZlQWN0aW9ucy5nZXQoJ2RyYWdFbmRMaXN0ZW5lcicpLnN0b3AoKTtcbiAgICAgICAgc2V0KCdkcmFnRW5kJyk7XG4gICAgICAgIGlmIChvbkRyYWdFbmQpIG9uRHJhZ0VuZChlKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfSlcbik7XG5cbmV4cG9ydCBjbGFzcyBEaW1lbnNpb25zIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuY3VycmVudCA9IHt9O1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH1cbiAgXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9XG5cbiAgbWVhc3VyZSgpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBoYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC53aWR0aCAhPT0gdW5kZWZpbmVkO1xuICB9XG59XG4iXX0=