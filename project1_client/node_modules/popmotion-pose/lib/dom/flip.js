"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var value_1 = require("popmotion/reactions/value");
var action_1 = require("popmotion/action");
exports.Action = action_1.Action;
var ORIGIN_START = 0;
var ORIGIN_CENTER = '50%';
var ORIGIN_END = '100%';
var findCenter = function (_a) {
    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
    return ({
        x: (left + right) / 2,
        y: (top + bottom) / 2
    });
};
var positionalProps = new Set([
    'width',
    'height',
    'top',
    'left',
    'bottom',
    'right'
]);
var checkPositionalProp = function (key) { return positionalProps.has(key); };
var hasPositionalProps = function (pose) {
    return Object.keys(pose).some(checkPositionalProp);
};
exports.isFlipPose = function (pose, key) {
    return hasPositionalProps(pose) || key === 'flip';
};
var setValue = function (_a, key, to) {
    var values = _a.values, elementStyler = _a.elementStyler;
    if (values.has(key)) {
        var val = values.get(key);
        val.update(to);
        val.update(to);
    }
    else {
        values.set(key, value_1.default(to, function (v) { return elementStyler.set(key, v); }));
    }
};
var explicitlyFlipPose = function (state, nextPose) {
    var dimensions = state.dimensions, elementStyler = state.elementStyler;
    dimensions.measure();
    var width = nextPose.width, height = nextPose.height, top = nextPose.top, left = nextPose.left, bottom = nextPose.bottom, right = nextPose.right, remainingPose = __rest(nextPose, ["width", "height", "top", "left", "bottom", "right"]);
    elementStyler.set({
        width: width,
        height: height,
        top: top,
        left: left,
        bottom: bottom,
        right: right
    }).render();
    return implicitlyFlipPose(state, remainingPose);
};
var implicitlyFlipPose = function (state, nextPose) {
    var dimensions = state.dimensions, element = state.element, elementStyler = state.elementStyler;
    if (!dimensions.has())
        return {};
    var prev = dimensions.get();
    var transform = element.style.transform;
    element.style.transform = '';
    var next = element.getBoundingClientRect();
    element.style.transform = transform;
    var originX = prev.left === next.left ? ORIGIN_START : prev.right === next.right ? ORIGIN_END : ORIGIN_CENTER;
    var originY = prev.top === next.top ? ORIGIN_START : prev.bottom === next.bottom ? ORIGIN_END : ORIGIN_CENTER;
    elementStyler.set({ transformOrigin: originX + " " + originY });
    var flipPoseProps = {};
    if (prev.width !== next.width) {
        setValue(state, 'scaleX', prev.width / next.width);
        flipPoseProps.scaleX = 1;
    }
    if (prev.height !== next.height) {
        setValue(state, 'scaleY', prev.height / next.height);
        flipPoseProps.scaleY = 1;
    }
    var prevCenter = findCenter(prev);
    var nextCenter = findCenter(next);
    if (originX === ORIGIN_CENTER) {
        setValue(state, 'x', prevCenter.x - nextCenter.x);
        flipPoseProps.x = 0;
    }
    if (originY === ORIGIN_CENTER) {
        setValue(state, 'y', prevCenter.y - nextCenter.y);
        flipPoseProps.y = 0;
    }
    elementStyler.render();
    return __assign({}, nextPose, flipPoseProps);
};
exports.flipPose = function (state, nextPose) {
    return hasPositionalProps(nextPose)
        ? explicitlyFlipPose(state, nextPose)
        : implicitlyFlipPose(state, nextPose);
};
//# sourceMappingURL=flip.js.map